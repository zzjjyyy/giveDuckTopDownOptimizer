//---------------------------------------------------------------------------
//	@filename:
//		COptimizationContext.h
//
//	@doc:
//		Optimization context object stores properties required to hold
//		on the plan generated by the optimizer
//---------------------------------------------------------------------------
#pragma once

#include "duckdb/optimizer/cascade/base.h"
#include "duckdb/optimizer/cascade/base/CRequiredPhysicalProp.h"
#include "duckdb/optimizer/cascade/search/CJobQueue.h"

#define GPOPT_INVALID_OPTCTXT_ID gpos::ulong_max

namespace gpopt {
using namespace gpos;

// forward declarations
class CGroup;
class CGroupExpression;
class CCostContext;
class COptimizationContext;
class CRequiredLogicalProp;

// optimization context pointer definition
typedef duckdb::unique_ptr<COptimizationContext> OPTCTXT_PTR;

//---------------------------------------------------------------------------
//	@class:
//		COptimizationContext
//
//	@doc:
//		Optimization context
//
//---------------------------------------------------------------------------
class COptimizationContext {
public:
	// states of optimization context
	enum EState { estUnoptimized, estOptimizing, estOptimized, estSentinel };

public:
	// dummy ctor; used for creating invalid context
	COptimizationContext()
	    : m_id(GPOPT_INVALID_OPTCTXT_ID), m_group(nullptr), m_required_plan_properties(nullptr),
	      m_required_relational_properties(nullptr), m_search_stage(0), m_best_cost_context(nullptr),
	      m_estate(estUnoptimized), m_has_multi_stage_agg_plan(false) {};

	//---------------------------------------------------------------------------
	// ctor
	// @inputs:
	//	 CRequiredLogicalProp* prprel: required relational props -- used during stats derivation
	//	 IStatisticsArray* stats_ctxt: stats of previously optimized expressions
	//---------------------------------------------------------------------------
	COptimizationContext(duckdb::unique_ptr<CGroup> pgroup, duckdb::unique_ptr<CRequiredPhysicalProp> prpp,
						 duckdb::unique_ptr<CRequiredLogicalProp> prprel, ULONG search_stage_index)
	    : m_id(GPOPT_INVALID_OPTCTXT_ID), m_group(pgroup), m_required_plan_properties(prpp),
	      m_required_relational_properties(prprel), m_search_stage(search_stage_index), m_best_cost_context(nullptr),
	      m_estate(estUnoptimized), m_has_multi_stage_agg_plan(false) {
	}

	COptimizationContext(const COptimizationContext &) = delete;

	virtual ~COptimizationContext();

	// unique id within owner group, used for debugging
	ULONG m_id;

	// back pointer to owner group, used for debugging
	duckdb::unique_ptr<CGroup> m_group;

	// required plan properties
	duckdb::unique_ptr<CRequiredPhysicalProp> m_required_plan_properties;

	// required relational properties -- used for stats computation during costing
	duckdb::unique_ptr<CRequiredLogicalProp> m_required_relational_properties;

	// index of search stage where context is generated
	ULONG m_search_stage;

	// best cost context under the optimization context
	duckdb::unique_ptr<CCostContext> m_best_cost_context;

	// optimization context state
	EState m_estate;

	// is there a multi-stage Agg plan satisfying required properties
	bool m_has_multi_stage_agg_plan;

	// context's optimization job queue
	CJobQueue m_opt_job_queue;

	// link for optimization context hash table in CGroup
	SLink m_link;

	// invalid optimization context, needed for hash table iteration
	static const COptimizationContext M_INVALID_OPT_CONTEXT;

	// invalid optimization context pointer, needed for cost contexts hash table iteration
	static const OPTCTXT_PTR M_INVALID_OPT_CONTEXT_PTR;

public:
	// internal matching function
	bool FMatchSortColumns(duckdb::unique_ptr<COptimizationContext> poc) const;
	
	// best group expression accessor
	duckdb::unique_ptr<CGroupExpression> BestExpression() const;
	
	// match optimization contexts
	bool Matches(const duckdb::unique_ptr<COptimizationContext> poc) const;
	
	// search stage index accessor
	ULONG UlSearchStageIndex() const {
		return m_search_stage;
	}

	// optimization job queue accessor
	CJobQueue* PjqOptimization() {
		return &m_opt_job_queue;
	}

	// set optimization context id
	void SetId(ULONG id) {
		m_id = id;
	}

	// set optimization context state
	void SetState(EState estNewState) {
		m_estate = estNewState;
	}

	// set best cost context
	void SetBest(duckdb::unique_ptr<CCostContext> pcc);

	size_t HashValue() {
		return m_required_plan_properties->HashValue();
	}

	// hash function for optimization context
	static size_t HashValue(const COptimizationContext &oc) {
		return oc.m_required_plan_properties->HashValue();
	}

	// equality function for cost contexts hash table
	static bool Equals(const OPTCTXT_PTR &pocLeft, const OPTCTXT_PTR &pocRight) {
		if (pocLeft == M_INVALID_OPT_CONTEXT_PTR || pocRight == M_INVALID_OPT_CONTEXT_PTR) {
			return pocLeft == M_INVALID_OPT_CONTEXT_PTR && pocRight == M_INVALID_OPT_CONTEXT_PTR;
		}
		return pocLeft->Matches(pocRight);
	}

	// hash function for cost contexts hash table
	static size_t HashValue(const OPTCTXT_PTR &poc) {
		return HashValue(*poc);
	}

	// hash function used for computing stats during costing
	static ULONG UlHashForStats(const duckdb::unique_ptr<COptimizationContext> poc) {
		return HashValue(*poc);
	}

	// equality function used for computing stats during costing
	static bool FEqualForStats(const duckdb::unique_ptr<COptimizationContext> pocLeft,
							   const duckdb::unique_ptr<COptimizationContext> pocRight);
	
	// check if Agg node should be optimized for the given context
	static bool FOptimizeAgg(duckdb::unique_ptr<CGroupExpression> pgexprParent,
							 duckdb::unique_ptr<CGroupExpression> pgexprAgg,
							 duckdb::unique_ptr<COptimizationContext> poc,
	                         ULONG ulSearchStages);

	// check if Sort node should be optimized for the given context
	static bool FOptimizeSort(duckdb::unique_ptr<CGroupExpression> pgexprParent,
							  duckdb::unique_ptr<CGroupExpression> pgexprSort,
							  duckdb::unique_ptr<COptimizationContext> poc,
	                          ULONG ulSearchStages);

	// check if Motion node should be optimized for the given context
	static bool FOptimizeMotion(duckdb::unique_ptr<CGroupExpression> pgexprParent,
								duckdb::unique_ptr<CGroupExpression> pgexprMotion,
	                            duckdb::unique_ptr<COptimizationContext> poc, ULONG ulSearchStages);
	
	// check if NL join node should be optimized for the given context
	static bool FOptimizeNLJoin(duckdb::unique_ptr<CGroupExpression> pgexprParent,
								duckdb::unique_ptr<CGroupExpression> pgexprMotion,
	                            duckdb::unique_ptr<COptimizationContext> poc, ULONG ulSearchStages);
	
	// return true if given group expression should be optimized under given context
	static bool FOptimize(duckdb::unique_ptr<CGroupExpression> pgexprParent,
						  duckdb::unique_ptr<CGroupExpression> pgexprChild,
						  duckdb::unique_ptr<COptimizationContext> pocChild,
	                      ULONG ulSearchStages);
	
	// compare array of contexts based on context ids
	static bool FEqualContextIds(duckdb::vector<duckdb::unique_ptr<COptimizationContext>> pdrgpocFst,
	                             duckdb::vector<duckdb::unique_ptr<COptimizationContext>> pdrgpocSnd);

	// compute required properties to CTE producer based on plan properties of CTE consumer
	// static CRequiredPhysicalProp *PrppCTEProducer(duckdb::unique_ptr<COptimizationContext> poc, ULONG ulSearchStages);
}; // class COptimizationContext
} // namespace gpopt